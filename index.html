<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>agraj - Portfolio</title>
    <link rel="icon" type="image/png" href="frieren.png">

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Baloo+Bhai+2:wght@700&family=Inter:wght@400;500;600;700&family=Lato:ital,wght@0,400;0,700;1,400&family=Outfit:wght@400;500;700&family=Nunito:wght@400;700&family=Fuzzy+Bubbles:wght@400;700&display=swap" rel="stylesheet">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Anime.js for animations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <!-- Matter.js for physics game -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

    <script>
        // --- Tailwind Configuration ---
        window.tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'dark': '#0f0a19', 'darker': '#090613', 'accent': '#9272CE',
                        'accent-hover': '#AE8BD5', 'light-accent': '#CBB8E8',
                        'text-primary': '#ffffff', 'text-secondary': '#D1D1D1', 'text-tertiary': '#A8A8A8',
                        'article-bg': 'rgba(20, 20, 22, 0.93)',
                        'writings-card-bg': 'rgba(25, 15, 40, 0.88)',
                        'writings-card-hover-bg': 'rgba(45, 35, 60, 0.96)',
                        'dark-purple-bg': '#1a0a2e',
                        'hover-highlight': 'rgba(146, 114, 206, 0.1)',
                        'brand-purple': '#9272CE', 'brand-hover': '#AE8BD5',
                        'brand-light-purple': '#CBB8E8', 'brand-dark': '#050505',
                        'brand-light': '#FFFFFF', 'brand-gray': '#D1D1D1', 'brand-text': '#A8A8A8',
                        'correct-answer-bg': 'rgba(146, 114, 206, 0.35)',
                        'selected-wrong-bg': 'rgba(100, 100, 100, 0.3)',
                        'disabled-option-bg': 'rgba(30, 20, 50, 0.7)',
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'], serif: ['Baloo Bhai 2', 'cursive'],
                        lato: ['Lato', 'sans-serif'], outfit: ['Outfit', 'sans-serif'],
                        nunito: ['Nunito', 'sans-serif'], 'fuzzy-bubbles': ['Fuzzy Bubbles', 'cursive'],
                        verdana: ['Verdana', 'sans-serif'], 'trebuchet': ['Trebuchet MS', 'sans-serif'],
                    },
                }
            }
        };
    </script>

    <style>
        /* --- Global Styles --- */
        html { scroll-behavior: smooth; }
        body {
            background-color: #0f0a19; color: #D1D1D1; font-family: 'Inter', sans-serif;
            overflow-x: hidden; line-height: 1.6; font-size: 16px;
        }
        h1, h2, h3, h4, h5, h6 { color: #ffffff; font-weight: 700; }
        .font-serif { font-family: 'Baloo Bhai 2', cursive; }
        .font-outfit { font-family: 'Outfit', sans-serif; }

        /* --- Backgrounds --- */
        #hyperspeed-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -10; background-color: #07040e; }
        .bg-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle at 50% 30%, rgba(146, 114, 206, 0.03), rgba(15, 10, 25, 0.85) 70%); z-index: -5; pointer-events:none; }

        /* --- Page Section Management --- */
        .page-section { display: none; animation: fadeInPage 0.7s ease-out forwards; }
        .page-section.active-section { display: block; }
        @keyframes fadeInPage { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* --- Typography & Effects --- */
        .gradient-text { background: linear-gradient(90deg, #FFFFFF, #CBB8E8, #9272CE, #CBB8E8, #FFFFFF); background-size: 300% auto; background-clip: text; -webkit-background-clip: text; color: transparent; animation: gradientTextAnim 8s linear infinite; display: inline-block; }
        @keyframes gradientTextAnim { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
        .typed-cursor { display: inline-block; width: 2px; background-color: #9272CE; margin-left: 4px; animation: pulseCursor 1s infinite; vertical-align: text-bottom; }
        #home-content h1 .typed-cursor { height: 1em; background-color: #CBB8E8; }
        #home-content blockquote .typed-cursor { background-color: #A8A8A8; }
        #typewriter .typed-cursor, #main-heading-text .typed-cursor, #blockquote-text .typed-cursor { height: 1.1em; } /* Consolidating cursor height */
        @keyframes pulseCursor { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
        /* Minimum height for typewriter elements to prevent layout shifts */
        #typewriter { min-height: 3em; display: inline-block; width: 100%; }
        #main-heading-text { min-height: 1.2em; display: inline-block; }
        #blockquote-text { min-height: 4em; display: inline-block; }

        /* --- Scrollbar Styling --- */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: rgba(9, 6, 19, 0.8); }
        ::-webkit-scrollbar-thumb { background: rgba(146, 114, 206, 0.5); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(146, 114, 206, 0.7); }

        /* --- Header --- */
        .main-header { position: sticky; top: 0; left: 0; width: 100%; background-color: rgba(9, 6, 19, 0.85); backdrop-filter: blur(10px); z-index: 50; border-bottom: 1px solid rgba(146, 114, 206, 0.1); box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        .main-header .nav-logo { font-family: 'Baloo Bhai 2', cursive; transition: color 0.3s ease; }
        .main-header .nav-logo:hover { color: #9272CE; }

        /* Desktop Nav */
        .desktop-nav a { position: relative; display: inline-block; transition: color 0.3s ease; }
        .desktop-nav a::after { content: ''; position: absolute; bottom: -3px; left: 0; width: 0; height: 1.5px; background-color: #9272CE; transition: width 0.3s ease; }
        .desktop-nav a:hover::after { width: 100%; }
        .desktop-nav a:hover, .desktop-nav a.active { color: #9272CE; }
        .desktop-nav a.active::after { width: 100%; }

        /* Mobile Nav Toggle */
        .nav-toggle-btn { background: none; border: none; padding: 0.5rem; cursor: pointer; z-index: 60; }
        .nav-toggle-btn svg { stroke: #ffffff; transition: stroke 0.3s ease; }
        .nav-toggle-btn:hover svg { stroke: #9272CE; }

        /* Mobile Menu */
        .mobile-menu { display: none; position: absolute; top: 100%; left: 0; width: 100%; background-color: rgba(9, 6, 19, 0.95); backdrop-filter: blur(8px); padding: 1rem 0; box-shadow: 0 10px 20px rgba(0,0,0,0.4); z-index: 55; animation: slideDownFade 0.4s ease-out forwards; }
        .mobile-menu.is-open { display: block; }
        .mobile-menu a { display: block; padding: 0.8rem 1.5rem; font-size: 1.1rem; transition: color 0.3s ease, background-color 0.3s ease; text-align: center; }
        .mobile-menu a:hover { color: #9272CE; background-color: rgba(146, 114, 206, 0.1); }
        .mobile-menu a.active { background-color: rgba(146, 114, 206, 0.1); font-weight: 600; color: #9272CE; }
        @keyframes slideDownFade { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }

        /* External Link Icon for Nav */
        .desktop-nav a[target="_blank"]::after, .mobile-menu a[target="_blank"]::after { content: ' \2197'; font-size: 0.7em; vertical-align: super; display: inline-block; margin-left: 2px; opacity: 0.7; width: auto !important; height: auto !important; background: none !important; }

        /* --- Home Section (#home-content) --- */
        #heroSection { text-align: center; padding-top: 1rem; min-height: 70vh; display: flex; flex-direction: column; justify-content: center; }
        #hero-circular-profile-image-container { margin-bottom: 1.5rem; }
        #hero-circular-profile-image { width: 130px; height: 130px; border-radius: 50%; object-fit: cover; border: 3px solid rgba(146, 114, 206, 0.4); box-shadow: 0 0 20px rgba(146, 114, 206, 0.25); display: block; margin: 0 auto; opacity: 0; transform: scale(0.8) translateY(10px); transition: opacity 0.8s ease-out 0.2s, transform 0.8s ease-out 0.2s; } /* Initial state & animation transition */

        /* Quote Block */
        #home-content .quote { position: relative; border-left: 3px solid #9272CE; margin-top: 1.5rem; }
        #home-content .quote::before { content: '"'; position: absolute; top: -20px; left: 10px; font-size: 5rem; color: rgba(146, 114, 206, 0.1); font-family: 'Inter', sans-serif; font-weight: 700; z-index: -1; } /* Added z-index */

        /* Card Styles (used for home recent writings) */
        #home-content .card { transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); background: rgba(15, 10, 25, 0.75); border: 1px solid rgba(146, 114, 206, 0.2); position: relative; overflow: hidden; } /* Added position & overflow */
        #home-content .card::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(90deg, transparent, rgba(146, 114, 206, 0.1), transparent); transform: translateX(-100%); transition: transform 0.8s ease; pointer-events: none; }
        #home-content .card:hover { box-shadow: 0 15px 30px rgba(9, 6, 19, 0.6), 0 0 20px rgba(146, 114, 206, 0.35); border-color: rgba(146, 114, 206, 0.45); }
        #home-content .card:hover::before { transform: translateX(100%); }

        /* Link Hover Effect (used for home read more links) */
        #home-content .hover-link { position: relative; display: inline-block; }
        #home-content .hover-link::after { content: ''; position: absolute; bottom: -2px; left: 0; width: 0; height: 1px; background-color: #9272CE; transition: width 0.3s ease; }
        #home-content .hover-link:hover::after { width: 100%; }

        /* Static Image (Frieren Ring) */
        .static-image-container { display: block; margin: 2.5rem auto 0 auto; width: fit-content; opacity: 0.8; transition: opacity 0.3s ease; z-index: 5; }
        .static-image { width: 8rem; height: 8rem; cursor: pointer; transition: transform 0.3s ease; }
        .static-image:hover { transform: scale(1.1); }

        /* View All Writings Button on Home */
        #home-content .view-all-writings-btn { background-color: #9272CE; color: #FFFFFF; font-weight: 500; border-radius: 0.5rem; }
        #home-content .view-all-writings-btn:hover { background-color: #AE8BD5; }


        /* --- Writings Section (#writings-content) --- */
        #writings-content { font-size: 17px; }
        #writings-content .text-hover-scale { transition: transform 0.25s ease-out; display: inline-block; }
        #writings-content .text-hover-scale:hover { transform: scale(1.03); }

        /* Writings Preview Cards */
        .writing-preview-card { background-color: var(--card-bg, rgba(25, 15, 40, 0.9)); backdrop-filter: blur(7px); border-radius: 0.75rem; padding: 2rem; border: 1px solid rgba(146, 114, 206, 0.25); display: flex; flex-direction: column; transition: transform 0.3s ease-out, box-shadow 0.4s ease-out, border-color 0.4s ease-out, background-color 0.3s ease; box-shadow: 0 6px 18px rgba(0,0,0, 0.35), 0 0 8px 1px rgba(146, 114, 206, 0.2); }
        .writing-preview-card:hover { transform: translateY(-10px) scale(1.03); background-color: var(--card-hover-bg, rgba(45, 35, 60, 0.97)); animation: cardGlowWritings 1.8s ease-in-out infinite alternate; }
        @keyframes cardGlowWritings { 0% { box-shadow: 0 0 10px 2px rgba(146, 114, 206, 0.25), 0 6px 18px rgba(0,0,0, 0.35); border-color: rgba(174, 139, 213, 0.35); } 50% { box-shadow: 0 0 22px 5px rgba(146, 114, 206, 0.4), 0 10px 28px rgba(0, 0, 0, 0.3); border-color: rgba(174, 139, 213, 0.65); } 100% { box-shadow: 0 0 10px 2px rgba(146, 114, 206, 0.25), 0 6px 18px rgba(0,0,0, 0.35); border-color: rgba(174, 139, 213, 0.35); } }
        .writing-preview-card h3 { color: #FFFFFF; font-size: 1.55rem; font-weight: 600; margin-bottom: 0.75rem; font-family: 'Outfit', sans-serif; }
        .writing-preview-card .post-meta-info { font-size: 0.9rem; color: #CBB8E8; margin-bottom: 1.25rem; font-family: 'Lato', sans-serif; opacity: 0.9; }
        .writing-preview-card .excerpt { color: #D1D1D1; font-size: 1.05rem; line-height: 1.65; flex-grow: 1; margin-bottom: 1.5rem; }
        .writing-preview-card a.read-more-link { display: inline-block; background: none; border: none; padding: 0; color: #9272CE; font-weight: 500; text-decoration: none; align-self: flex-start; cursor: pointer; transition: color 0.3s ease; font-size: 1.05rem; margin-top: auto; }
        .writing-preview-card a.read-more-link:hover { color: #AE8BD5; text-decoration: underline; }

        /* Full Article Display */
        #full-articles-container { display: block; margin-top: 2rem; }
        #full-articles-container article { display: none; background-color: rgba(20, 20, 22, 0.94); backdrop-filter: blur(10px); border-radius: 0.75rem; padding: 2.5rem 2rem; margin-bottom: 3rem; box-shadow: 0 10px 40px rgba(0,0,0, 0.6), inset 0 1px 3px rgba(146, 114, 206, 0.1); border: 1px solid rgba(146, 114, 206, 0.3); border-top: 5px solid #9272CE; opacity: 0; }
        #full-articles-container article:target { display: block !important; opacity: 1 !important; animation: fadeInArticle 0.6s ease-out forwards; }
        @keyframes fadeInArticle { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

        /* Hide grid and separator when an article is active */
        #writings-grid-container:has(~ #full-articles-container article:target) { display: none; }
        hr.separator:has(~ #full-articles-container article:target) { display: none; }

        #full-articles-container h2 { color: #9272CE; margin-bottom: 0.75rem; font-size: 2.1rem; font-weight: 700; font-family: 'Outfit', sans-serif; line-height: 1.3; }
        #full-articles-container .post-meta-info { font-size: 0.95rem; color: #CBB8E8; margin-bottom: 2.5rem; font-family: 'Lato', sans-serif; opacity: 0.85; }

        /* Back Button */
        a.back-button { display: inline-block; margin-top: 2.5rem; padding: 0.7rem 1.4rem; background-color: #9272CE; color: #FFFFFF; border: none; border-radius: 0.5rem; font-weight: 500; cursor: pointer; transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease; box-shadow: 0 3px 10px rgba(146, 114, 206, 0.2); font-size: 1rem; text-decoration: none; }
        a.back-button:hover { background-color: #AE8BD5; transform: scale(1.05) translateY(-2px); box-shadow: 0 8px 20px rgba(146, 114, 206, 0.3); }

        /* Separator Line */
        hr.separator { border: none; height: 2px; background-image: linear-gradient(to right, transparent, #9272CE, #AE8BD5, #9272CE, transparent); margin-top: 3rem; margin-bottom: 3rem; opacity: 0.6; display: block; }

        /* Article Content Styling (HTML generated from Markdown) */
        .post-content-html { white-space: pre-line; text-align: left; line-height: 1.7; }
        .post-content-html p, .post-content-html blockquote, .post-content-html span, .post-content-html div, .post-content-html b, .post-content-html strong, .post-content-html i, .post-content-html em, .post-content-html u, .post-content-html a { font-family: inherit; font-size: 1.1rem; color: #D1D1D1; background-color: transparent !important; margin: 0 0 0.8em 0; font-weight: normal; font-style: normal; text-decoration: none; word-wrap: break-word; border-radius: 3px; }
        .post-content-html br { content: ""; display: block; margin-bottom: 0.1em; }
        .post-content-html span { margin: 0; display: inline; } /* Ensure spans don't become block elements unexpectedly */
        /* Font family overrides for specific spans/divs (if used in content) */
        .post-content-html [style*="font-family: Outfit"] { font-family: 'Outfit', sans-serif !important; }
        .post-content-html [style*="font-family: Nunito"] { font-family: 'Nunito', sans-serif !important; }
        .post-content-html [style*="font-family: Fuzzy Bubbles"] { font-family: 'Fuzzy Bubbles', cursive !important; }
        .post-content-html [style*="font-family: verdana"] { font-family: 'Verdana', sans-serif !important; }
        .post-content-html [style*="font-family: trebuchet"] { font-family: 'Trebuchet MS', sans-serif !important; }
        /* Text style overrides */
        .post-content-html b, .post-content-html strong, .post-content-html [style*="font-weight: bold"] { font-weight: 700 !important; }
        .post-content-html i, .post-content-html em, .post-content-html [style*="font-style: italic"] { font-style: italic !important; }
        .post-content-html u { text-decoration: underline !important; }
        .post-content-html a { color: #9272CE !important; text-decoration: underline !important; transition: color 0.2s ease; display: inline !important; }
        .post-content-html a:hover { color: #AE8BD5 !important; }
        /* Text alignment overrides */
        .post-content-html p[style*="text-align: center;"], .post-content-html div[style*="text-align: center;"], .post-content-html blockquote[style*="text-align: center;"] { text-align: center !important; margin-left: auto; margin-right: auto; }
        /* Blockquote styles */
        .post-content-html blockquote { border-left: 4px solid #9272CE; padding: 1em 1.75rem; margin: 1em 0; font-style: italic; color: #A8A8A8; background-color: rgba(146, 114, 206, 0.05); }
        .post-content-html blockquote blockquote { margin-top: 1em; margin-left: 1.5rem; border-left-color: #AE8BD5; padding-left: 1rem; background-color: rgba(174, 139, 213, 0.05); }
        .post-content-html blockquote p { margin-bottom: 0.75em; } /* Restore margin for paragraphs within blockquotes */
        /* Image styles */
        .post-content-html img { max-width: 100%; height: auto; display: block; margin: 2.5rem auto; border-radius: 0.75rem; box-shadow: 0 6px 20px rgba(0,0,0,0.4); transition: transform 0.3s ease, box-shadow 0.3s ease; }
        .post-content-html img:hover { transform: scale(1.03); box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        .post-content-html .separator { display: none; } /* Hide separators within post content */

        /* Tailwind utility layer additions */
        @layer utilities {
            .line-clamp-3 { overflow: hidden; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 3; }
            .line-clamp-4 { overflow: hidden; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 4; }
        }

        /* --- Glitch Button and General Interactive Elements --- */
        .glitch-button { position: relative; display: inline-block; cursor: pointer; padding: 0.75rem 1.5rem; text-decoration: none; overflow: hidden; transition: transform 0.1s ease-out; -webkit-user-select: none; -ms-user-select: none; user-select: none; border: none; } /* Added border: none */
        .glitch-button .btn-text { position: relative; z-index: 1; }
        .glitch-button::before, .glitch-button::after { content: attr(data-text); position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: inherit; color: inherit; padding: inherit; overflow: hidden; transition: transform 0.3s cubic-bezier(0.75, 0, 0.25, 1), opacity 0.3s ease; opacity: 0; z-index: 2; /* Added z-index */ }
        .glitch-button:not(:disabled):hover::before { transform: translate(-3px, -2px) skewX(-5deg); text-shadow: 2px 0px #FF00FF; opacity: 0.8; animation: glitchEffectBefore 0.2s infinite alternate; }
        .glitch-button:not(:disabled):hover::after { transform: translate(3px, 2px) skewX(5deg); text-shadow: -2px 0px #00FFFF; opacity: 0.8; animation: glitchEffectAfter 0.2s infinite alternate-reverse; }
        .glitch-button:active:not(:disabled) { transform: scale(0.97); } /* Apply active state only if not disabled */

        /* --- Footer, Progress Bar --- */
        .main-footer { background-color: rgba(9, 6, 19, 0.7); border-top: 1px solid rgba(146, 114, 206, 0.1); padding: 2rem 0; margin-top: 4rem; text-align: center; position: relative; z-index: 10; } /* Ensure z-index is high enough */
        .progress-container { position: fixed; top: 0; left: 0; width: 100%; height: 3px; z-index: 100; }
        .progress-bar { height: 3px; background: linear-gradient(90deg, #9272CE, #AE8BD5); width: 0%; }


        /* --- SECRET GAME STYLES --- */
        #secret-game-trigger { cursor: cell; display: inline-block; opacity: 0.5; transition: opacity 0.3s; user-select: none; /* Prevent selection */ }
        #secret-game-trigger:hover { opacity: 1; }
        #secret-game-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(9, 6, 19, 0.97); /* More opaque */
            backdrop-filter: blur(8px); /* Stronger blur */
            z-index: 1000;
            display: none; /* Initially hidden */
            flex-direction: column; align-items: center; justify-content: center;
            animation: fadeInGameModal 0.5s ease-out forwards;
        }
        @keyframes fadeInGameModal { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
        #matter-canvas {
            background-color: rgba(20, 15, 35, 0.6); /* Darker, slightly purplish canvas bg */
            border: 2px solid rgba(146, 114, 206, 0.4); /* Thicker, more visible border */
            border-radius: 8px; /* Rounded corners for canvas */
            box-shadow: 0 0 20px rgba(146, 114, 206, 0.2);
            max-width: 90%; /* Prevent overflow on small screens */
            max-height: 80%; /* Prevent overflow on small screens */
        }
        .game-controls {
            margin-top: 20px;
            display: flex; /* For reset and close side-by-side */
            gap: 15px; /* Space between buttons */
        }
        .game-controls button { /* Base style for game buttons */
            padding: 10px 20px;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.3s, transform 0.2s;
            font-family: 'Outfit', sans-serif;
        }
        #close-game-button { background-color: #7c5bab; /* Slightly muted purple */ }
        #close-game-button:hover { background-color: #6a4a9a; transform: scale(1.05); }
        #reset-game-button { background-color: #5887a7; /* A complementary blueish */ }
        #reset-game-button:hover { background-color: #4a7593; transform: scale(1.05); }

        #game-info {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 15px;
            background-color: rgba(0,0,0,0.4);
            border-radius: 5px;
            color: #CBB8E8;
            font-size: 0.9rem;
            text-align: center;
            min-width: 250px; /* Ensure enough space for text */
            z-index: 1001; /* Above canvas */
        }
        #game-info p { margin: 2px 0; }
        #game-win-message { font-weight: bold; color: #AE8BD5; transition: all 0.5s ease-out; } /* Added transition */
        .game-instructions {
            color: #A8A8A8;
            font-size: 0.85rem;
            margin-top: 5px;
        }

        /* --- ABOUT SECTION STYLES (#about-content) --- */
        #about-content .questionnaire-container-wrapper { max-width: 850px; margin-left: auto; margin-right: auto; }
        .question-block {
            background-color: rgba(28, 18, 52, 0.85);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(174, 139, 213, 0.35);
            border-radius: 1rem;
            padding: 2.25rem 2.5rem;
            margin-bottom: 3.5rem;
            box-shadow: 0 8px 30px rgba(0,0,0,0.4);
            min-height: 220px; /* Maintain consistent minimum height */
            display: flex;
            flex-direction: column;
            opacity: 0;
            transform: translateY(30px);
        }
         /* Override display property set by JS animation when not active */
        #about-content.active-section .question-block { display: flex !important; }

        .question-block h3 { color: #D7C2F2; font-size: 1.5rem; font-weight: 600; margin-bottom: 1.75rem; font-family: 'Outfit', sans-serif; }
        .answer-options { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.25rem; margin-bottom: 1.75rem; flex-grow: 1; }
        .answer-option {
            background-color: rgba(45, 30, 70, 0.8);
            color: #E0D8F0;
            padding: 1rem 1.3rem;
            border-radius: 0.75rem;
            border: 1px solid rgba(174, 139, 213, 0.45);
            cursor: pointer;
            transition: background-color 0.25s ease, border-color 0.25s ease, transform 0.2s ease-out, box-shadow 0.25s ease;
            text-align: left;
            font-size: 1.05rem;
            line-height: 1.4;
            opacity: 1;
            transform: scale(1);
        }
        .answer-option:not([disabled]):hover {
            background-color: rgba(174, 139, 213, 0.25);
            border-color: #AE8BD5;
            transform: translateY(-4px) scale(1.035);
            box-shadow: 0 5px 15px rgba(174, 139, 213, 0.25);
        }
        .answer-option.selected-visitor {
            background-color: #825FBD !important; /* Use !important to override hover */
            color: #FFFFFF !important;
            border-color: #CBB8E8 !important;
            font-weight: 700;
            box-shadow: 0 0 18px rgba(146, 114, 206, 0.7);
        }
        .answer-option.selected-visitor-wrong {
            background-color: var(--selected-wrong-bg, rgba(120, 120, 120, 0.45)) !important;
            color: #D8D8D8 !important;
            border-color: var(--text-tertiary, #A8A8A8) !important;
            font-weight: 500;
            box-shadow: 0 0 8px rgba(120, 120, 120, 0.25);
        }
        .answer-option.agraj-correct-answer {
            background-color: var(--correct-answer-bg, rgba(146, 114, 206, 0.55)) !important;
            color: #FFFFFF !important;
            border-color: #CBB8E8 !important;
            font-weight: 700;
            box-shadow: 0 0 15px rgba(174, 139, 213, 0.6);
        }
        .answer-option[disabled] {
            background-color: var(--disabled-option-bg, rgba(40, 30, 60, 0.75)) !important;
            color: #9a9a9a !important;
            cursor: not-allowed;
            border-color: rgba(146, 114, 206, 0.25) !important;
            opacity: 0.6 !important; /* Use !important to override animation opacity */
        }
        .answer-option[disabled]:not(.selected-visitor):not(.selected-visitor-wrong):not(.agraj-correct-answer) {
            opacity: 0.45 !important; /* Lower opacity for purely disabled, unselected options */
        }

        /* Feedback Area */
        .feedback-area { margin-top: auto; padding: 1.35rem; background-color: rgba(15, 10, 30, 0.9); border-radius: 0.6rem; border-left: 5px solid #AE8BD5; color: #D7C2F2; font-size: 1rem; line-height: 1.65; display: none; animation: fadeInFeedback 0.6s ease-out forwards; }
        .feedback-area.visible { display: block; }
        @keyframes fadeInFeedback { from { opacity: 0; transform: translateY(15px); } to { opacity: 1; transform: translateY(0); } }
        .feedback-area strong { color: #FFFFFF; font-weight: 700; }

        /* Personality Match Section */
        #personality-match-section {
            margin-top: 4rem;
            padding: 2.75rem;
            background-color: rgba(35, 25, 60, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 1rem;
            border: 1px solid rgba(174, 139, 213, 0.45);
            text-align: center;
            box-shadow: 0 10px 35px rgba(0,0,0,0.4);
            /* Initial state for animation, JS manages display */
            opacity: 0;
            transform: translateY(20px);
            display: none; /* Ensure it's hidden until animated in */
        }
        #personality-match-section.visible {
             display: block; /* Only set display: block when visible class is added by JS */
        }
        #personality-match-section h2 { color: #CBB8E8; font-size: 2.2rem; font-family: 'Outfit', sans-serif; margin-bottom: 2rem; }
        #personality-match-section p { font-size: 1.2rem; color: #E0D8F0; margin-bottom: 1.25rem; }
        #personality-match-section #match-percentage-value {
            font-weight: 700;
            font-size: 3.5rem;
            color: #FFFFFF;
            display: inline-block;
            margin: 0.5rem 0 1rem 0;
            padding: 0.3rem 0.8rem;
            border-radius: 0.5rem;
            background: linear-gradient(135deg, #AE8BD5, #9272CE);
            box-shadow: 0 4px 15px rgba(146, 114, 206, 0.4);
            /* Initial state for animation */
            opacity: 0;
            transform: scale(0.5);
        }
        #personality-match-section #mbti-type-value { font-weight: 600; color: #CBB8E8; font-size: 1.3rem; }
        #contact-telegram-btn {
            margin-top: 2rem;
            display: none; /* Managed by JS */
            background-color: #28A8EA;
            color: white;
            font-size: 1.1rem;
            padding: 0.9rem 1.8rem;
        }
        #contact-telegram-btn:hover {
            background-color: #229AC8;
        }

        /* Calculate Match Button */
        #calculate-match-button { margin-top: 3rem; padding: 1rem 2.2rem; background-color: #9272CE; color: #FFFFFF; border: none; border-radius: 0.6rem; font-weight: 600; font-size: 1.15rem; display: none; /* Managed by JS */ opacity: 0; /* Initial state for animation */ }
         #calculate-match-button:disabled { background: #5a506b; color: #a8a8a8; cursor: not-allowed; opacity: 0.7; }
        /* Disable glitch effect on disabled button */
        #calculate-match-button:disabled::before,
        #calculate-match-button:disabled::after { display: none; }

    </style>
</head>
<body>
    <!-- Audio elements for game and results sounds -->
    <audio id="gameSpawnSound" src="spawn_sound.mp3" preload="auto"></audio>
    <audio id="gameWinSound" src="win_sound.mp3" preload="auto"></audio>
    <audio id="revealSound" src="reveal_sound.mp3" preload="auto"></audio> <!-- For questionnaire results -->

    <!-- Hyperspeed Background and Overlay -->
    <canvas id="hyperspeed-canvas"></canvas>
    <div class="bg-overlay"></div>

    <!-- Scroll Progress Bar -->
    <div class="progress-container"> <div class="progress-bar" id="progressBar"></div> </div>

    <!-- Header Navigation -->
    <header class="main-header">
        <div class="container mx-auto px-6 py-4">
            <div class="flex justify-between items-center">
                <a href="#home" class="nav-logo text-2xl lg:text-3xl font-bold text-text-primary">a-g-r-a-j</a>
                <!-- Mobile Nav Toggle Button -->
                <button id="nav-toggle" class="nav-toggle-btn md:hidden" aria-label="Toggle Menu" aria-expanded="false">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" /></svg>
                </button>
                <!-- Desktop Navigation -->
                <nav class="desktop-nav hidden md:flex space-x-8 text-text-primary items-center">
                    <!-- Order links logically, e.g., Home, About, Writings, Contact -->
                    <a href="#home" data-navlink="home">Home</a>
                    <a href="#about" data-navlink="about">About Me</a>
                    <a href="#writings" data-navlink="writings">Writings</a>
                    <a href="https://t.me/agraj0669" target="_blank" rel="noopener noreferrer" data-navlink="contact">Contact Me</a>
                </nav>
            </div>
            <!-- Mobile Navigation Menu -->
            <nav id="mobile-menu" class="mobile-menu md:hidden">
                <a href="#home" data-navlink="home">Home</a>
                <a href="#about" data-navlink="about">About Me</a>
                <a href="#writings" data-navlink="writings">Writings</a>
                <a href="https://t.me/agraj0669" target="_blank" rel="noopener noreferrer" data-navlink="contact">Contact Me</a>
            </nav>
        </div>
    </header>

    <!-- Main Page Content Container -->
    <div id="page-container">
        <!-- Home Section -->
        <section id="home-content" class="page-section">
             <main class="container mx-auto px-4 md:px-6 pt-16 md:pt-24 pb-16">
                 <!-- Hero Section (About Me Intro) -->
                 <section class="opacity-0" id="heroSection">
                     <div id="hero-circular-profile-image-container">
                         <img src="agraj_profile.jpg" alt="Agraj Dubey" id="hero-circular-profile-image">
                     </div>
                     <div id="home-hero-text-content" class="w-full">
                         <h1 class="gradient-text text-5xl md:text-6xl lg:text-7xl font-bold mb-6 tracking-tight font-serif">
                             <span id="main-heading-text"></span>
                         </h1>
                         <p class="text-xl md:text-2xl text-text-secondary mb-10 md:mb-12 italic" id="typewriter"></p>
                         <blockquote class="quote max-w-xl mx-auto text-lg md:text-xl bg-darker/80 backdrop-blur-sm p-6 rounded-lg shadow-xl text-text-tertiary border-l-4 border-accent">
                             "<span id="blockquote-text"></span>"
                         </blockquote>
                     </div>
                 </section>

                 <!-- Recent Writings Preview Section -->
                 <section class="mb-16 opacity-0" id="writingsSectionHome">
                     <h2 class="text-3xl md:text-4xl font-bold text-center text-text-primary mt-16 mb-12">Recent Writings</h2>
                     <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8" id="home-recent-writings-grid">
                         <!-- Recent writing cards will be loaded here by JavaScript -->
                         <p class="text-text-secondary col-span-full text-center">Loading recent writings...</p>
                     </div>
                     <div class="text-center mt-12 md:mt-16">
                         <a href="#writings" class="view-all-writings-btn glitch-button" data-text="View All Writings">
                             <span class="btn-text">View All Writings</span>
                         </a>
                     </div>
                     <!-- Static Image / Easter Egg -->
                     <div id="staticImageContainerHome" class="static-image-container">
                         <img src="FrierenRing.png" alt="Ring Image" id="staticImageHome" class="static-image">
                     </div>
                 </section>
             </main>
        </section>

        <!-- Writings Section -->
        <section id="writings-content" class="page-section">
            <main class="container mx-auto px-6 py-16 md:py-20 min-h-screen">
                <div class="text-center mb-12 md:mb-16 pt-8">
                    <h1 class="text-4xl md:text-5xl font-bold text-text-primary font-outfit">My Writings</h1>
                </div>
                <!-- Writings Preview Grid -->
                <section id="writings-grid-container" class="mb-12 md:mb-20 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 md:gap-8">
                    <!-- Writing preview cards will be loaded here by JavaScript -->
                    <p class="text-text-secondary col-span-full text-center">Loading writings...</p>
                </section>
                <hr class="separator">
                <!-- Full Article View -->
                <section id="full-articles-container">
                    <div class="full-articles-content max-w-4xl mx-auto" id="full-articles-dynamic-content">
                        <!-- Full articles will be loaded here by JavaScript -->
                    </div>
                </section>
            </main>
        </section>

        <!-- About Me Section (Questionnaire) -->
        <section id="about-content" class="page-section">
            <main class="container mx-auto px-6 py-16 md:py-20 min-h-screen">
                <div class="text-center mb-12 md:mb-16 pt-8">
                    <h1 class="text-4xl md:text-5xl font-bold text-text-primary font-outfit">A Little More About Me</h1>
                    <p class="text-text-secondary mt-4 text-lg">Answer these questions to see how our perspectives align (or amusingly diverge!).</p>
                </div>
                <div id="questionnaire-container-wrapper" class="questionnaire-container-wrapper">
                    <div id="questionnaire-render-area">
                        <!-- Questionnaire content will be loaded here by JavaScript -->
                        <p class="text-center text-text-secondary">Loading questions...</p>
                    </div>
                    <!-- Personality Match Results Section -->
                    <div id="personality-match-section" class="mt-12">
                        <h2>Personality Snapshot</h2>
                        <p>Your alignment with my perspectives: <span id="match-percentage-value">0</span>%</p>
                        <p>My MBTI Type: <span id="mbti-type-value">INFJ</span></p>
                        <p class="text-sm text-text-tertiary mt-4">Note: This is a simplified alignment based on these specific questions.</p>
                        <a href="https://t.me/agraj0669" target="_blank" rel="noopener noreferrer" id="contact-telegram-btn" class="glitch-button mt-6" data-text="Contact on Telegram!">
                            <span class="btn-text">Contact on Telegram!</span>
                        </a>
                    </div>
                    <!-- Calculate Match Button -->
                    <div class="text-center">
                         <button id="calculate-match-button" class="glitch-button" data-text="See How We Match!"><span class="btn-text">See How We Match!</span></button>
                    </div>
                </div>
            </main>
        </section>
    </div>

    <!-- Footer -->
    <footer class="main-footer">
        <div class="container mx-auto px-6">
            <p class="text-text-tertiary">
                © <span id="currentYear"></span> agraj. All rights reserved.
                <span id="secret-game-trigger" title="?">🕹️</span>
            </p>
        </div>
    </footer>

    <!-- Secret Game Modal -->
    <div id="secret-game-modal">
        <div id="game-info">
            <p>Shapes dropped: <span id="game-shapes-dropped">0</span>/<span id="game-max-shapes">10</span></p> <!-- Default max shapes -->
            <p>In target: <span id="game-shapes-in-target">0</span>/<span id="game-shapes-to-win">3</span></p> <!-- Default shapes to win -->
            <p id="game-win-message" class="game-instructions">Drag shapes into the purple zone!</p>
        </div>
        <canvas id="matter-canvas"></canvas>
        <div class="game-controls">
            <button id="reset-game-button" class="glitch-button" data-text="Reset Game"><span class="btn-text">Reset Game</span></button>
            <button id="close-game-button" class="glitch-button" data-text="Close Game"><span class="btn-text">Close Game</span></button>
        </div>
    </div>


    <!-- --- Main JavaScript --- -->
    <script>
        // --- Configuration ---
        const APP_CONFIG = {
             ROTATING_TEXT_HOME: {
                'typewriter': { texts: ["Cause no one listens, so I write instead 😎"], typeSpeed: 80, deleteSpeed: 50, pauseDuration: 3000 },
                'main-heading-text': { texts: ["agraj", "アグラジ", "अग्रज", "αγραξ"], typeSpeed: 100, deleteSpeed: 60, pauseDuration: 2500 },
                'blockquote-text': { texts: ["If determinism holds, there's a chance I exit early—something dramatic. So I leave fragments of myself here—at least the algorithm remembers me better than my family will😒", "Is free will an illusion, or is the illusion the only free will we have?", "Perhaps the 'fragments' are the only coherent parts left.", "What if the algorithm forgets too?", "Maybe exiting early isn't dramatic, just... efficient.", "Family remembers differently. Algorithms remember precisely. Which is better?", "The universe is indifferent, but the code persists. For now.", "Do androids dream of electric sheep? Do algorithms dream of better data?", "To be, or not to be, that is the computation.", "Cogito, ergo sum... I think, therefore I am... coded?"], typeSpeed: 70, deleteSpeed: 40, pauseDuration: 4500 }
             },
              DEFAULT_TITLES: {
                 home: "agraj - Portfolio",
                 writings: "Writings - Agraj Dubey",
                 about: "About Me - Agraj Dubey"
             },
             POSTS_JSON_PATH: 'posts.json',
             QUESTIONS_JSON_PATH: 'questions.json',
             TELEGRAM_USERNAME: 'agraj0669',
             MATCH_THRESHOLD_FOR_CONTACT: 70, // Percentage threshold to show Telegram button
             GAME_MAX_SHAPES_TO_SPAWN: 10,
             GAME_SHAPES_TO_WIN: 3
        };

        // --- Global State Variables ---
        let ALL_POSTS_DATA = []; // Stores all writings data
        let ALL_QUESTIONNAIRE_DATA = []; // Stores all questions data
        let visitorAnswers = {}; // Stores visitor's selected answers
        let questionsAnsweredCount = 0; // Count of questions answered
        let currentMainSection = null; // ID of the currently active page section
        let lastClickedReadMoreLink = null; // Keep track for focus on back button
        let rotatingTextInstances = {}; // Stores instances/observers for typewriter effects

        // Secret Game state variables
        let matterEngine, matterRender, matterRunner;
        let gameShapes = []; // Array of bodies in the game
        let shapesSpawned = 0;
        let gameHasBeenWon = false;
        let targetZoneBody; // Matter.js body for the target zone
        let gameSpawnSoundEl, gameWinSoundEl, revealSoundEl; // Audio elements


        // --- Utility Functions ---
        function $(selector) { return document.querySelector(selector); }
        function $$(selector) { return document.querySelectorAll(selector); }

         /**
         * Simple markdown-like text processing to HTML.
         * Handles bold, italics, line breaks, quotes.
         * Intended for post content flexibility.
         */
        function simpleMarkdownToHtml(md) {
            if (typeof md !== 'string') return '';
            let html = md;

            // Handle inline code blocks if necessary (removed previous backtick logic as it seemed incomplete)

            // Replace <br> tags first to preserve them if accidentally in markdown
            html = html.replace(/<br\s*\/?>/gi, '[[BR_TAG]]');

            // Replace newlines with <br>\n for general text flow, preserving double newlines as paragraphs (or roughly)
            // This tries to handle paragraphs loosely based on multiple newlines
            html = html.replace(/\n\n/g, '[[PARAGRAPH]]'); // Mark paragraphs
            html = html.replace(/\n/g, '[[BR_TAG]]'); // Replace single newlines with <br>
            html = html.replace(/\[\[PARAGRAPH\]\]/g, '<p>'); // Convert paragraph marks to <p> (simple, may need refinement)

             // Basic bold and italic
            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>'); // **bold**
            html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');         // *italic*

             // Basic quotes (look for lines starting with >)
            html = html.replace(/^>\s?(.*)$/gm, '<blockquote><p>$1</p></blockquote>'); // Single line quotes

            // Simple links [text](url)
             html = html.replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2">$1</a>');

            // Restore <br> tags and clean up
            html = html.replace(/\[\[BR_TAG\]\]/g, '<br>\n'); // Restore <br> tags
            html = html.replace(/(<br>\n\s*){3,}/gi, '<br>\n<br>\n'); // Reduce excessive line breaks

            return html;
        }

        function isElementInViewport(el) {
            if(!el) return false;
            const rect = el.getBoundingClientRect();
            return (
                rect.top >= 0 &&
                rect.left >= 0 &&
                rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
                rect.right <= (window.innerWidth || document.documentElement.clientWidth)
            );
        }

        /** Plays a sound element if available and functional. */
        function playSound(soundElement) {
            if (soundElement && typeof soundElement.play === 'function') {
                soundElement.currentTime = 0; // Rewind to start
                soundElement.play().catch(e => console.warn("Audio play failed:", e.message));
            }
        }


        // --- Hyperspeed Animation ---
        const hyperspeedCanvas = $('#hyperspeed-canvas');
        const hsCtx = hyperspeedCanvas.getContext('2d');
        let stars = [];
        const numStars = 400;
        let mouseX = window.innerWidth / 2;
        let mouseY = window.innerHeight / 2;
        let baseSpeed = 0.008;
        const aceFlagColors = ['#000000', '#A3A3A3', '#FFFFFF', '#800080']; // Black, Grey, White, Purple

        function resizeHyperspeedCanvas() {
            hyperspeedCanvas.width = window.innerWidth;
            hyperspeedCanvas.height = window.innerHeight;
            mouseX = hyperspeedCanvas.width / 2;
            mouseY = hyperspeedCanvas.height / 2;
        }

        function initStars() {
            stars = [];
            for (let i = 0; i < numStars; i++) {
                const randomAceColor = aceFlagColors[Math.floor(Math.random() * aceFlagColors.length)];
                stars.push({
                    x: Math.random() * 2 - 1,
                    y: Math.random() * 2 - 1,
                    z: Math.random() * 1.8 + 0.2, // Depth
                    color: randomAceColor,
                    opacity: Math.random() * 0.4 + 0.2
                });
            }
        }

        function animateHyperspeed() {
            hsCtx.clearRect(0, 0, hyperspeedCanvas.width, hyperspeedCanvas.height);
            const centerX = hyperspeedCanvas.width / 2;
            const centerY = hyperspeedCanvas.height / 2;

            stars.forEach(star => {
                const screenX = centerX + (star.x / star.z) * centerX;
                const screenY = centerY + (star.y / star.z) * centerY;

                // Calculate speed based on mouse proximity
                let currentSpeedFactor = 1;
                const dxMouse = screenX - mouseX;
                const dyMouse = screenY - mouseY;
                const distMouse = Math.sqrt(dxMouse * dxMouse + dyMouse * dyMouse);
                // Increase speed significantly if mouse is close
                if (distMouse < 100) {
                    currentSpeedFactor = 1 + (5 * (1 - distMouse / 100)); // Max 6x speed at center
                }


                star.z -= baseSpeed * currentSpeedFactor;

                // Reset star if it passes the screen
                if (star.z <= 0.005) { // Check near zero to reset
                    star.x = Math.random() * 2 - 1;
                    star.y = Math.random() * 2 - 1;
                    star.z = Math.random() * 1.8 + 0.2;
                    star.color = aceFlagColors[Math.floor(Math.random() * aceFlagColors.length)];
                    star.opacity = Math.random() * 0.4 + 0.2;
                }

                // Calculate size and opacity based on depth
                const size = Math.max(0.3, (1 / star.z) * 2.5); // Prevent size from being too small
                const dynamicOpacity = Math.min(1, (star.opacity + (1 / star.z) * 0.3)); // Appear brighter as they get closer

                // Only draw if within canvas bounds (with a buffer)
                 if (screenX > -size && screenX < hyperspeedCanvas.width + size && screenY > -size && screenY < hyperspeedCanvas.height + size) {
                    // Handle alpha for hex colors, special case for black
                    if (star.color === '#000000' && dynamicOpacity > 0.1) {
                         hsCtx.fillStyle = `rgba(50,50,50, ${dynamicOpacity * 0.5})`; // Make black stars dark grey and less opaque
                    } else if (star.color.startsWith('#')) {
                        hsCtx.fillStyle = `${star.color}${Math.round(dynamicOpacity * 255).toString(16).padStart(2, '0')}`; // Convert hex + alpha
                    } else { // Assume rgba format already
                         hsCtx.fillStyle = `rgba(${star.color.slice(5,-1)}, ${dynamicOpacity})`;
                    }

                    hsCtx.beginPath();
                    hsCtx.arc(screenX, screenY, size, 0, Math.PI * 2);
                    hsCtx.fill();
                 }
            });

            requestAnimationFrame(animateHyperspeed);
        }


        // --- Writings Content Rendering ---
        /** Creates the HTML for a single post preview card. */
        function createPostPreviewCard(post, isForHome = false) {
            const cardClass = isForHome ? 'card' : 'writing-preview-card';
            // Add a data attribute for delay if it's for the home section for stagger animation
            const delay = isForHome && ALL_POSTS_DATA.length > 0 ? (ALL_POSTS_DATA.slice(0,3).indexOf(post) * 150) : 0;

            // Determine the target section (full article)
             const articleLink = `#post-${post.id}`;

            return `
                <div class="${cardClass} rounded-lg p-7 shadow-lg relative overflow-hidden" ${isForHome ? `data-delay="${delay}"` : ''}>
                    <h3 class="text-xl lg:text-2xl font-semibold text-text-primary mb-4 group ${!isForHome ? 'text-hover-scale font-outfit' : ''}">
                        <span class="${isForHome ? 'hover:text-accent' : ''} transition-all duration-300 inline-block">${post.title}</span>
                    </h3>
                    ${!isForHome ? `<div class="post-meta-info">${new Date(post.date).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}</div>` : ''}
                    <div class="mb-5"><p class="text-text-secondary line-clamp-${isForHome ? 3 : 4} ${!isForHome ? 'excerpt' : ''}">${post.excerpt}</p></div>
                    <a href="${articleLink}" class="${isForHome ? 'text-accent hover:text-accent-hover font-medium inline-flex items-center hover-link' : 'read-more-link glitch-button'}" data-text="Read More →">
                        <span class="${!isForHome ? 'btn-text' : ''}">Read More ${!isForHome ? '→' : ''}</span>
                         ${isForHome ? '<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 ml-1" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3" /></svg>' : ''}
                    </a>
                </div>
            `;
        }

        /** Creates the HTML for a full article. */
        function createFullArticleHtml(post) {
            const htmlContent = simpleMarkdownToHtml(post.contentMarkdown);
            return `
                <article id="post-${post.id}" tabindex="-1"> <!-- Added post- prefix to ID -->
                    <h2 class="text-hover-scale">${post.title}</h2>
                    <div class="post-meta-info">Published: ${new Date(post.date).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}</div>
                    ${post.image ? `<img src="${post.image}" alt="${post.imageAlt || post.title}" class="my-8 rounded-lg shadow-lg mx-auto max-w-full md:max-w-2xl" loading="lazy">` : ''}
                    <div class="post-content-html">${htmlContent}</div>
                    <a href="#writings" class="back-button mt-8 glitch-button" data-text="← Back to Writings"><span class="btn-text">← Back to Writings</span></a>
                </article>
            `;
        }

        /** Fetches posts.json, sorts and renders them into the DOM. */
        async function loadAndRenderPosts() {
            console.log("Attempting to load posts...");
            const homeGrid = $('#home-recent-writings-grid');
            const writingsGrid = $('#writings-grid-container');
            const fullArticlesTarget = $('#full-articles-dynamic-content');

            // Clear previous content and show loading state
            if (homeGrid) homeGrid.innerHTML = '<p class="text-text-secondary col-span-full text-center">Loading recent writings...</p>';
            if (writingsGrid) writingsGrid.innerHTML = '<p class="text-text-secondary col-span-full text-center">Loading writings...</p>';
            if (fullArticlesTarget) fullArticlesTarget.innerHTML = '';


            try {
                const response = await fetch(APP_CONFIG.POSTS_JSON_PATH);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}, path: ${APP_CONFIG.POSTS_JSON_PATH}`);
                }
                ALL_POSTS_DATA = await response.json();
                // Sort by date, newest first
                ALL_POSTS_DATA.sort((a, b) => new Date(b.date) - new Date(a.date));

                // Render Home Section Recent Writings
                const recentPosts = ALL_POSTS_DATA.slice(0, 3);
                if (homeGrid) {
                    if (recentPosts.length > 0) {
                         homeGrid.innerHTML = recentPosts.map(post => createPostPreviewCard(post, true)).join('');
                         setupHomeCardHoverEffects(); // Apply effects after rendering
                         setupHomeScrollAnimations(); // Setup observers for cards
                    } else {
                        homeGrid.innerHTML = '<p class="text-text-secondary col-span-full text-center">No recent writings to display.</p>';
                    }
                }

                // Render Writings Section Grid
                if (writingsGrid) {
                     if (ALL_POSTS_DATA.length > 0) {
                         writingsGrid.innerHTML = ALL_POSTS_DATA.map(post => createPostPreviewCard(post, false)).join('');
                     } else {
                         writingsGrid.innerHTML = '<p class="text-text-secondary col-span-full text-center">No writings available.</p>';
                     }
                }

                // Render Full Articles (initially hidden by CSS :target)
                 if (fullArticlesTarget) {
                     if (ALL_POSTS_DATA.length > 0) {
                        fullArticlesTarget.innerHTML = ALL_POSTS_DATA.map(post => createFullArticleHtml(post)).join('');
                     } else {
                        fullArticlesTarget.innerHTML = '<p class="text-text-secondary col-span-full text-center">No articles to display.</p>';
                     }
                 }

            } catch (error) {
                console.error("ERROR in loadAndRenderPosts:", error);
                if (homeGrid) homeGrid.innerHTML = '<p class="text-text-secondary col-span-full text-center">Error loading recent writings.</p>';
                if (writingsGrid) writingsGrid.innerHTML = '<p class="text-text-secondary col-span-full text-center">Error loading writings.</p>';
                 if (fullArticlesTarget) fullArticlesTarget.innerHTML = '<p class="text-text-secondary col-span-full text-center">Error loading articles.</p>';
            }
        }


        // --- Questionnaire Logic (About Me Section) ---
        /** Fetches questions.json and renders the questionnaire structure. */
        async function renderQuestionnaire() {
            const container = $('#questionnaire-render-area');
            const calculateButton = $('#calculate-match-button');
            const personalityMatchSection = $('#personality-match-section');
            const contactTelegramBtn = $('#contact-telegram-btn');

            // Check if essential elements exist
            if (!container || !calculateButton || !personalityMatchSection || !contactTelegramBtn) {
                console.error("One or more questionnaire UI elements not found. Aborting render.");
                if(container) container.innerHTML = '<p class="text-text-secondary text-center">Core UI elements missing for the About Me section.</p>';
                return;
            }

            // Show loading state initially
            container.innerHTML = '<p class="text-center text-text-secondary">Loading questions...</p>';

            // Fetch questions if not already loaded
            if (ALL_QUESTIONNAIRE_DATA.length === 0) {
                try {
                    const response = await fetch(APP_CONFIG.QUESTIONS_JSON_PATH);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status} for ${APP_CONFIG.QUESTIONS_JSON_PATH}`);
                    ALL_QUESTIONNAIRE_DATA = await response.json();
                } catch (error) {
                    console.error("Error loading questionnaire:", error);
                    container.innerHTML = `<p class="text-text-secondary text-center">Error loading questions. (${error.message})</p>`;
                    // Ensure interactive elements are hidden on error
                    calculateButton.style.display = 'none';
                    personalityMatchSection.style.display = 'none';
                    contactTelegramBtn.style.display = 'none';
                    return; // Stop execution if loading failed
                }
            }

            // If no questions were loaded
            if (ALL_QUESTIONNAIRE_DATA.length === 0) {
                container.innerHTML = '<p class="text-text-secondary text-center">No questions available.</p>';
                // Ensure interactive elements are hidden
                 calculateButton.style.display = 'none';
                 personalityMatchSection.style.display = 'none';
                 contactTelegramBtn.style.display = 'none';
                return;
            }

            // Build HTML for the questionnaire
            let html = '';
            ALL_QUESTIONNAIRE_DATA.forEach((q) => {
                html += `
                    <div class="question-block" id="question-${q.id}" data-question-id="${q.id}">
                        <h3>${q.questionText}</h3>
                        <div class="answer-options">
                `;
                q.options.forEach((opt) => {
                    // Escape quotes in data-option-text
                    const escapedOptionText = String(opt.text).replace(/"/g, '&quot;');
                    html += `<button class="answer-option" data-option-text="${escapedOptionText}">${opt.text}</button>`;
                });
                html += `
                        </div>
                        <div class="feedback-area" id="feedback-${q.id}"></div>
                    </div>
                `;
            });

            // Render questionnaire HTML
            container.innerHTML = html;

            // Animate question blocks into view
            if (typeof anime === 'function') {
                anime({
                    targets: '.question-block',
                    translateY: [30, 0],
                    opacity: [0, 1],
                    delay: anime.stagger(120, { start: 100 }),
                    duration: 600,
                    easing: 'easeOutExpo'
                });
            }

            // Reset state
            visitorAnswers = {};
            questionsAnsweredCount = 0;

            // Hide match section and button initially
            personalityMatchSection.style.display = 'none';
            personalityMatchSection.classList.remove('visible');
            // Reset opacity and transform for re-animation if needed
            personalityMatchSection.style.opacity = '0';
            personalityMatchSection.style.transform = 'translateY(20px)';
            contactTelegramBtn.style.display = 'none';
            calculateButton.style.display = 'none';
            calculateButton.disabled = true; // Disable until all questions are answered

            // Set up click listeners for answer options
            setupQuestionnaireInteractions();
        }

        /** Sets up event listeners for the answer options. */
        function setupQuestionnaireInteractions() {
            const answerOptionButtons = $$('#questionnaire-render-area .answer-option');
            const calculateButton = $('#calculate-match-button');

            answerOptionButtons.forEach(button => {
                // Use a single delegated listener on the container for efficiency
                 // But the existing loop with individual listeners is fine for this scale too.
                 // Let's stick to the loop for simplicity with the current structure.
                button.addEventListener('click', function() {
                    const questionBlock = this.closest('.question-block');
                    // Prevent answering again if already answered
                    if (questionBlock.classList.contains('answered')) return;

                    const questionId = questionBlock.dataset.questionId;
                    const selectedOptionText = this.dataset.optionText; // Use data attribute for text

                    // Find the corresponding question data
                    const questionData = ALL_QUESTIONNAIRE_DATA.find(q => q.id === questionId);
                    if (!questionData) {
                        console.error(`Question data not found for ID: ${questionId}`);
                        return;
                    }

                    // Mark this question block as answered
                    questionBlock.classList.add('answered');

                    // Increment answered count only if this is the first answer for this question
                    if (!visitorAnswers.hasOwnProperty(questionId)) {
                        questionsAnsweredCount++;
                    }
                    visitorAnswers[questionId] = selectedOptionText; // Store the visitor's answer

                    const optionsInBlock = questionBlock.querySelectorAll('.answer-option');

                    // Update state and appearance for all options in this block
                    optionsInBlock.forEach(opt => {
                        opt.disabled = true; // Disable all options in this block
                        // Remove any previous state classes
                        opt.classList.remove('selected-visitor', 'selected-visitor-wrong', 'agraj-correct-answer');

                         // Animate other options to fade out slightly
                        if (opt !== this && typeof anime === 'function') {
                             anime({ targets: opt, opacity: 0.4, scale: 0.95, duration: 400, easing: 'easeOutQuad' });
                         }
                    });

                    // Apply state classes and animations based on correctness
                    let animParams = { targets: this, duration: 400, easing: 'easeOutBack' }; // Animation for the clicked button

                    if (selectedOptionText === questionData.agrajAnswerText) {
                        // Visitor chose the correct answer
                        this.classList.add('selected-visitor'); // Use selected-visitor as their choice was correct
                         animParams.scale = [1, 1.05, 1]; // Add a little bounce
                        // Background color set by CSS class
                    } else {
                        // Visitor chose a wrong answer
                        this.classList.add('selected-visitor-wrong');
                         // Background color set by CSS class
                        // Find and highlight Agraj's correct answer
                        const agrajAnswerButton = Array.from(optionsInBlock).find(optBtn => optBtn.dataset.optionText === questionData.agrajAnswerText);
                        if (agrajAnswerButton) {
                            agrajAnswerButton.classList.add('agraj-correct-answer');
                             if (typeof anime === 'function') {
                                anime({
                                     targets: agrajAnswerButton,
                                     scale: [1, 1.03, 1], // Little highlight bounce for correct answer
                                     backgroundColor: tailwind.theme.extend.colors['correct-answer-bg'] || 'rgba(146,114,206,0.55)',
                                     duration: 400,
                                     delay:100, // Slight delay after visitor's choice animates
                                     easing: 'easeOutBack'
                                 });
                            }
                        }
                    }

                    // Run animation for the clicked button
                    if (typeof anime === 'function') anime(animParams);

                    // Show the feedback area
                    const feedbackArea = questionBlock.querySelector('.feedback-area');
                    feedbackArea.innerHTML = selectedOptionData.feedback; // Display feedback text
                    feedbackArea.classList.add('visible'); // Make it visible
                    if (typeof anime === 'function') {
                        anime({ targets: feedbackArea, opacity: [0, 1], translateY: [10,0], duration: 500, delay: 200, easing: 'easeOutExpo' });
                    }


                    // Check if all questions are answered and show/hide the calculate button
                    if (ALL_QUESTIONNAIRE_DATA.length > 0 && questionsAnsweredCount === ALL_QUESTIONNAIRE_DATA.length) {
                        // All questions answered
                        if(calculateButton.style.display === 'none') { // Prevent re-animating if already visible
                            calculateButton.style.display = 'inline-block';
                            calculateButton.disabled = false;
                             if (typeof anime === 'function') {
                                anime({ targets: calculateButton, opacity: [0, 1], scale: [0.8, 1], duration: 500, easing: 'easeOutExpo' });
                            }
                        }
                    } else {
                        // Not all questions answered yet
                         calculateButton.style.display = 'none'; // Hide button
                         calculateButton.disabled = true;
                    }
                });
            });

            // Add event listener for the calculate button (will only be active when enabled)
            if (calculateButton) calculateButton.addEventListener('click', calculateAndShowMatch);
        }

        /** Calculates the match percentage and shows the results section. */
        function calculateAndShowMatch() {
            const calcButton = $('#calculate-match-button');
            // Disable the button immediately to prevent multiple clicks
            if(calcButton) calcButton.disabled = true;

            // Ensure all questions are answered before proceeding
            if (ALL_QUESTIONNAIRE_DATA.length === 0 || questionsAnsweredCount < ALL_QUESTIONNAIRE_DATA.length) {
                 console.warn("Calculate match called before all questions were answered.");
                 if(calcButton) calcButton.disabled = false; // Re-enable if somehow triggered early
                 return;
            }

            // Calculate matches
            let matches = 0;
            ALL_QUESTIONNAIRE_DATA.forEach(qData => {
                const visitorSelectedText = visitorAnswers[qData.id];
                 // Ensure both exist and are strings before comparing
                if (visitorSelectedText && typeof visitorSelectedText === 'string' && typeof qData.agrajAnswerText === 'string' &&
                    visitorSelectedText.trim() === qData.agrajAnswerText.trim()) {
                    matches++;
                }
            });

            const totalQuestions = ALL_QUESTIONNAIRE_DATA.length;
            const percentage = totalQuestions > 0 ? Math.round((matches / totalQuestions) * 100) : 0;
            console.log(`Final Match: ${matches}/${totalQuestions} = ${percentage}%`);

            const percentageEl = $('#match-percentage-value');
            const personalityMatchSection = $('#personality-match-section');
            const contactTelegramBtn = $('#contact-telegram-btn');

            // Ensure UI elements exist before trying to update
            if (!percentageEl || !personalityMatchSection || !contactTelegramBtn) {
                console.error("Required UI elements for personality match section not found.");
                if(calcButton) calcButton.disabled = false;
                return;
            }

             // Set initial value and prepare for animation
            percentageEl.textContent = 0; // Start counting from 0
            percentageEl.style.opacity = '0';
            percentageEl.style.transform = 'scale(0.5)'; // Initial smaller size

            // Play the reveal sound
            playSound(revealSoundEl);

            // Show the personality match section
            personalityMatchSection.style.display = 'block';

            // Animate the section and the percentage value
            if (typeof anime === 'function') {
                anime.timeline({ easing: 'easeOutExpo' })
                .add({
                    targets: personalityMatchSection,
                    opacity: [0, 1],
                    translateY: [30, 0],
                    duration: 700,
                    begin: () => personalityMatchSection.classList.add('visible') // Add class for persistent display
                })
                .add({
                    targets: percentageEl,
                    opacity: [0,1],
                    scale: [0.5, 1.1, 1], // Scale animation (small -> big -> normal)
                    duration: 800,
                    update: function(anim) { // Update the text content during the animation
                        percentageEl.textContent = Math.round(anim.animations[0].currentValue * (percentage / 100)); // Count up to the actual percentage
                    },
                    complete: function() { // Ensure final value is correct after animation
                         percentageEl.textContent = percentage;
                    }
                }, '-=400') // Start this animation 400ms before the previous one ends
                 .add({ // Animate other text elements in the section
                    targets: [$('#personality-match-section h2'), $('#personality-match-section p:not(:has(#match-percentage-value))'), $('#personality-match-section #mbti-type-value'), $('#personality-match-section p.text-sm')], // Select specific paragraphs
                    opacity: [0,1],
                    translateY: [10,0],
                    delay: anime.stagger(100), // Stagger animation for these elements
                    duration: 500
                }, '-=500') // Start this animation 500ms before the percentage animation ends
                .finished.then(() => {
                    // After all animations, scroll the section into view
                    personalityMatchSection.scrollIntoView({ behavior: 'smooth', block: 'center' });

                    // Show Telegram button if match is high enough
                    if (percentage >= APP_CONFIG.MATCH_THRESHOLD_FOR_CONTACT) {
                        contactTelegramBtn.style.display = 'inline-block';
                        if (typeof anime === 'function') {
                             anime({targets: contactTelegramBtn, opacity: [0,1], scale: [0.8,1], duration: 500, easing: 'easeOutExpo'});
                         }
                    } else {
                        contactTelegramBtn.style.display = 'none'; // Ensure it's hidden otherwise
                    }
                    // The calculate button remains disabled
                });
            } else {
                // Fallback if anime.js is not available
                 percentageEl.textContent = percentage;
                 percentageEl.style.opacity = '1';
                 percentageEl.style.transform = 'scale(1)';
                 personalityMatchSection.style.opacity = '1';
                 personalityMatchSection.style.transform = 'translateY(0)';
                 personalityMatchSection.classList.add('visible');
                 personalityMatchSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
                 if (percentage >= APP_CONFIG.MATCH_THRESHOLD_FOR_CONTACT) {
                     contactTelegramBtn.style.display = 'inline-block';
                 } else {
                     contactTelegramBtn.style.display = 'none';
                 }
                 // calculate button remains disabled
            }
        }


        // --- Secret Game Logic (Matter.js) ---
        /** Plays a sound element if available and functional. */
         function playSound(soundElement) {
             if (soundElement && typeof soundElement.play === 'function') {
                 soundElement.currentTime = 0; // Rewind to start
                 soundElement.play().catch(e => console.warn("Audio play failed:", e.message));
             }
         }

        /** Resets the physics game state. */
        function resetSecretGame() {
            console.log("Resetting game...");
            gameHasBeenWon = false;
            shapesSpawned = 0;
            gameShapes = []; // Clear the array of bodies

            // Clear all bodies from the world except static ones (if needed, or re-add static)
            if (matterEngine && matterEngine.world) {
                 // A simpler approach: recreate engine or carefully remove all non-static bodies
                 // Let's clear and re-add static bodies for guaranteed reset
                 Matter.Composite.clear(matterEngine.world, false); // Clear all bodies but preserve constraints/composites

                 // Re-add static bodies (ground, walls, target zone)
                const canvas = $('#matter-canvas');
                const canvasWidth = parseFloat(canvas.width);
                const canvasHeight = parseFloat(canvas.height);

                // Re-create and add static bodies
                const ground = Matter.Bodies.rectangle(canvasWidth / 2, canvasHeight - 10, canvasWidth + 20, 60, { isStatic: true, label: 'ground', render: { fillStyle: '#6a4a9a' } });
                const leftWall = Matter.Bodies.rectangle(-30, canvasHeight / 2, 60, canvasHeight, { isStatic: true, label: 'leftWall', render: { fillStyle: '#6a4a9a' } });
                const rightWall = Matter.Bodies.rectangle(canvasWidth + 30, canvasHeight / 2, 60, canvasHeight, { isStatic: true, label: 'rightWall', render: { fillStyle: '#6a4a9a' } });

                const targetZoneHeight = 50;
                // Position target zone above the ground, with a small gap
                const targetZoneY = canvasHeight - 30 - (targetZoneHeight / 2) - 10;
                targetZoneBody = Matter.Bodies.rectangle(canvasWidth / 2, targetZoneY, canvasWidth * 0.5, targetZoneHeight, {
                    isStatic: true, isSensor: true, label: 'targetZone', // isSensor prevents collision response
                    render: { fillStyle: 'rgba(174, 139, 213, 0.35)', strokeStyle: 'rgba(203, 184, 232, 0.6)', lineWidth: 2 }
                });

                Matter.Composite.add(matterEngine.world, [ground, leftWall, rightWall, targetZoneBody]);
            }

            // Reset game info display
            if ($('#game-win-message')) $('#game-win-message').textContent = "Drag shapes into the purple zone!";
            updateGameInfoDisplay(); // Update counts to 0
        }

        /** Updates the game info text display. */
        function updateGameInfoDisplay() {
            if ($('#game-shapes-dropped')) $('#game-shapes-dropped').textContent = shapesSpawned;
            if ($('#game-max-shapes')) $('#game-max-shapes').textContent = APP_CONFIG.GAME_MAX_SHAPES_TO_SPAWN;

            let shapesInTargetCount = 0;
            if (targetZoneBody) { // Ensure targetZoneBody exists
                 gameShapes.forEach(shape => {
                    // Check if the center of the shape is within the target zone bounds
                    // and if the shape has settled (low velocity)
                    if (Matter.Bounds.overlaps({min: shape.position, max: shape.position}, targetZoneBody.bounds) &&
                        Math.abs(shape.velocity.x) < 0.5 && Math.abs(shape.velocity.y) < 0.5) { // Check velocity threshold
                        shapesInTargetCount++;
                    }
                });
            }

            if ($('#game-shapes-in-target')) $('#game-shapes-in-target').textContent = shapesInTargetCount;
            if ($('#game-shapes-to-win')) $('#game-shapes-to-win').textContent = APP_CONFIG.GAME_SHAPES_TO_WIN;

            // Check for win condition
            if (!gameHasBeenWon && shapesInTargetCount >= APP_CONFIG.GAME_SHAPES_TO_WIN) {
                gameHasBeenWon = true;
                if ($('#game-win-message')) $('#game-win-message').textContent = "YOU WIN! ✨";
                playSound(gameWinSoundEl); // Play win sound
                 // Animate the win message
                 if (typeof anime === 'function') {
                    anime({ targets: '#game-win-message', scale: [1, 1.2, 1], color: ['#AE8BD5', '#FFFFFF', '#AE8BD5'], duration: 1000, easing: 'easeInOutQuad' });
                }
            } else if (!gameHasBeenWon && shapesSpawned >= APP_CONFIG.GAME_MAX_SHAPES_TO_SPAWN && shapesInTargetCount < APP_CONFIG.GAME_SHAPES_TO_WIN) {
                 // Check for lose condition (out of shapes and haven't won)
                 if ($('#game-win-message')) $('#game-win-message').textContent = "Out of shapes! Try again?";
            }
        }

        /** Sets up the Secret Game (Matter.js). */
        function setupSecretGame() {
            const trigger = $('#secret-game-trigger');
            const modal = $('#secret-game-modal');
            const canvas = $('#matter-canvas');
            const closeButton = $('#close-game-button');
            const resetButton = $('#reset-game-button');

            // Get audio elements
            gameSpawnSoundEl = $('#gameSpawnSound');
            gameWinSoundEl = $('#gameWinSound');

            // Check if all necessary elements and Matter.js are available
            if (!trigger || !modal || !canvas || !closeButton || !resetButton || typeof Matter === 'undefined') {
                 if(trigger) trigger.style.display = 'none'; // Hide trigger if game can't load
                console.warn("Secret game elements not found or Matter.js missing. Game disabled.");
                return;
            }

            // Matter.js modules
            const Engine = Matter.Engine, Render = Matter.Render, Runner = Matter.Runner,
                  Bodies = Matter.Bodies, Composite = Matter.Composite, Mouse = Matter.Mouse,
                  MouseConstraint = Matter.MouseConstraint, Events = Matter.Events;

            // Event listener to open the game modal
            trigger.addEventListener('click', () => {
                modal.style.display = 'flex'; // Show modal
                 if (typeof anime === 'function') { // Animate modal entry
                    anime({ targets: modal, opacity: [0,1], scale: [0.9, 1], duration: 400, easing: 'easeOutExpo' });
                }

                // Stop and clear any previous engine/render instances
                if (matterRender) Matter.Render.stop(matterRender);
                if (matterRunner) Runner.stop(matterRunner);
                if (matterEngine) Matter.Engine.clear(matterEngine);
                // Clear any old canvas instances if Render created them in a div
                if (canvas.parentElement) {
                    Array.from(canvas.parentElement.children).forEach(child => {
                        if (child.tagName === 'CANVAS' && child !== canvas) {
                            child.remove();
                        }
                    });
                }

                // Create a new Matter.js engine
                matterEngine = Engine.create({
                     gravity: { y: 0.8 } // Slightly stronger gravity for snappier drops
                });

                // Determine canvas size based on current window size
                let canvasWidth = Math.min(window.innerWidth * 0.85, 700);
                let canvasHeight = Math.min(window.innerHeight * 0.75, 450);
                canvas.width = canvasWidth; // Set actual canvas element size
                canvas.height = canvasHeight;
                canvas.style.width = `${canvasWidth}px`; // Set CSS size
                canvas.style.height = `${canvasHeight}px`;

                // Create a Matter.js renderer
                matterRender = Render.create({
                    element: modal, // Render inside the modal div
                    canvas: canvas, // Use the existing canvas element
                    engine: matterEngine,
                    options: {
                        width: canvasWidth,
                        height: canvasHeight,
                        wireframes: false, // Use colored shapes
                        background: 'transparent' // Canvas itself is transparent, modal background shows through
                    }
                });
                 // Render.create might add the canvas inside the element, check if it does
                 // if (modal.querySelector('canvas') !== canvas) { modal.appendChild(canvas); } // Ensure the canvas is in the modal if not already


                // Setup static walls and target zone
                resetSecretGame();

                // Add mouse interaction
                const mouse = Mouse.create(matterRender.canvas);
                const mouseConstraint = MouseConstraint.create(matterEngine, {
                    mouse: mouse,
                    constraint: { stiffness: 0.1, render: { visible: false } }
                });
                Composite.add(matterEngine.world, mouseConstraint);
                // Keep the mouse object for the renderer to enable interaction
                matterRender.mouse = mouse;


                // Add event listener to spawn shapes on mouse click
                Events.on(mouseConstraint, 'mousedown', (event) => {
                    // Prevent spawning if game is won or max shapes reached
                    if (gameHasBeenWon || shapesSpawned >= APP_CONFIG.GAME_MAX_SHAPES_TO_SPAWN) {
                         // Maybe play a different sound or show a message?
                        return;
                    }

                    const mousePosition = event.mouse.position;
                    let body;
                    const size = Math.random() * 20 + 15; // Random size between 15 and 35
                    // Randomly pick a color from the palette
                    const color = ['#CBB8E8', '#AE8BD5', '#FFFFFF', '#9272CE'][Math.floor(Math.random() * 4)];

                    // Alternate between circles and rectangles
                    if (shapesSpawned % 2 === 0) {
                        body = Bodies.rectangle(mousePosition.x, mousePosition.y, size, size, {
                            render: { fillStyle: color },
                            frictionAir: 0.03, // Add some air friction
                            restitution: 0.4 // Some bounce
                        });
                    } else {
                         body = Bodies.circle(mousePosition.x, mousePosition.y, size / 1.8, { // Radius for circle
                            render: { fillStyle: color },
                            frictionAir: 0.02,
                            restitution: 0.6 // More bounce for circles
                        });
                    }

                    // Add the created body to the world
                    Composite.add(matterEngine.world, body);
                    gameShapes.push(body); // Add to our tracking array
                    shapesSpawned++; // Increment spawn counter

                    playSound(gameSpawnSoundEl); // Play spawn sound
                    updateGameInfoDisplay(); // Update UI counts
                });

                // Add event listener for afterUpdate to check win condition
                Events.on(matterEngine, 'afterUpdate', updateGameInfoDisplay);


                // Start the renderer and runner
                Render.run(matterRender);
                matterRunner = Runner.create();
                Runner.run(matterRunner, matterEngine);

                 // Initial update of game info display
                 updateGameInfoDisplay();
            });

            // Event listener to close the game modal
            closeButton.addEventListener('click', () => {
                 if (typeof anime === 'function') { // Animate modal exit
                    anime({
                        targets: modal, opacity: [1,0], scale: [1, 0.9], duration: 300, easing: 'easeInExpo',
                        complete: () => modal.style.display = 'none' // Hide modal after animation
                    });
                } else {
                    modal.style.display = 'none'; // Just hide if no anime.js
                }
                // Stop the Matter.js engine and render loop
                if (matterRender) Matter.Render.stop(matterRender);
                if (matterRunner) Runner.stop(matterRunner);
                // Clear the engine to release resources
                if (matterEngine) Matter.Engine.clear(matterEngine);
                 // Clear the gameShapes array
                gameShapes = [];
                 // Remove canvas element created by Render.run if it was added inside modal (optional, but clean)
                // if (modal.querySelector('canvas') !== canvas) { modal.querySelector('canvas')?.remove(); }

            });

            // Event listener to reset the game
            resetButton.addEventListener('click', resetSecretGame);
        }


        // --- SPA Routing and Navigation ---
        /** Shows the specified main section and hides others. */
        function showMainSection(sectionId) {
            // Hide all page sections
            $$('.page-section').forEach(section => {
                section.classList.remove('active-section');
                // Optionally pause animations/typewriters for hidden sections
                if (section.id === 'home-content') {
                     // Logic to pause home animations/typewriters if needed
                }
            });

            // Show the target section
            const targetSection = $(`#${sectionId}`);
            if (targetSection) {
                targetSection.classList.add('active-section');
                currentMainSection = sectionId; // Update state

                // Update navigation active state
                $$('.desktop-nav a, .mobile-menu a').forEach(navLink => {
                    navLink.classList.remove('active');
                    // Map navlink data-navlink to section IDs
                    const navTarget = navLink.dataset.navlink;
                    if ( (sectionId === 'home-content' && navTarget === 'home') ||
                         (sectionId === 'writings-content' && navTarget === 'writings') ||
                         (sectionId === 'about-content' && navTarget === 'about') ||
                         (sectionId.startsWith('post-') && navTarget === 'writings') // Special case for article detail view
                       )
                    {
                        navLink.classList.add('active');
                    }
                });

                // Perform actions specific to the newly active section
                if (sectionId === 'home-content') {
                    animateCircularProfileImage(); // Animate profile image
                    // Setup/resume typewriter effects for Home sections
                    for (const elId in APP_CONFIG.ROTATING_TEXT_HOME) {
                        const rotEl = document.getElementById(elId);
                         // Check if setupRotatingText exists before calling
                        if(rotEl && typeof setupRotatingText === 'function') {
                             setupRotatingText(elId, APP_CONFIG.ROTATING_TEXT_HOME[elId]);
                        }
                    }
                     document.title = APP_CONFIG.DEFAULT_TITLES.home;
                } else if (sectionId === 'about-content') {
                    // Render questionnaire when About section is active
                    if(typeof renderQuestionnaire === 'function') renderQuestionnaire();
                    document.title = APP_CONFIG.DEFAULT_TITLES.about;
                } else if (sectionId === 'writings-content') {
                    // Logic specific to the main writings page ( handled by handleWritingsArticleLogic)
                     document.title = APP_CONFIG.DEFAULT_TITLES.writings;
                }
                 // Scroll to the top of the new section
                window.scrollTo({ top: 0, behavior: 'auto' });
            }
        }

        /** Handles routing based on the URL hash. */
        function handleMainRouteChange() {
            let mainSectionTarget = 'home-content'; // Default section
            let articleDetailHash = ''; // To store specific article hash

            const currentFullHash = window.location.hash;

            if (currentFullHash.startsWith('#post-')) {
                // If hash is for a specific post, show writings section and pass the hash
                mainSectionTarget = 'writings-content';
                articleDetailHash = currentFullHash;
            } else if (currentFullHash === '#writings') {
                mainSectionTarget = 'writings-content';
            } else if (currentFullHash === '#about') {
                mainSectionTarget = 'about-content';
            } else if (currentFullHash === '#home' || currentFullHash === '' || currentFullHash === '#') {
                mainSectionTarget = 'home-content';
                // If hash is empty or just '#', redirect to #home for clarity
                if (currentFullHash === '' || currentFullHash === '#') {
                    window.location.hash = 'home';
                    return; // Exit to prevent showing home twice
                }
            } else {
                // If hash is unrecognized, redirect to #home
                console.warn(`Unrecognized hash: ${currentFullHash}. Redirecting to #home.`);
                window.location.hash = 'home';
                return; // Exit to prevent showing home twice
            }

            // Only call showMainSection if the main section target has changed
            if (currentMainSection !== mainSectionTarget) {
                 showMainSection(mainSectionTarget);
            } else {
                 // If the main section is the same but it's writings and the hash is for an article,
                 // handle the article-specific logic
                 if (mainSectionTarget === 'writings-content' && articleDetailHash) {
                      if(typeof handleWritingsArticleLogic === 'function') handleWritingsArticleLogic(articleDetailHash);
                 }
                 // If it's the about section and it's already active, re-render questionnaire to reset state
                 if (mainSectionTarget === 'about-content' && currentMainSection === 'about-content') {
                     if(typeof renderQuestionnaire === 'function') renderQuestionnaire();
                 }
            }

            // Handle logic specific to the writings section (showing/hiding grid/article)
            if (mainSectionTarget === 'writings-content') {
                if(typeof handleWritingsArticleLogic === 'function') handleWritingsArticleLogic(articleDetailHash);
            } else if (mainSectionTarget === 'about-content') {
                 document.title = APP_CONFIG.DEFAULT_TITLES.about;
            } else { // Home or any other non-specific hash (should redirect to home)
                document.title = APP_CONFIG.DEFAULT_TITLES.home;
            }
        }

        /** Manages the display of the writings grid vs full articles based on hash. */
        function handleWritingsArticleLogic(articleHash) {
            const writingsGridContainer = $('#writings-grid-container');
            const fullArticlesContainer = $('#full-articles-container');
            const separator = $('hr.separator'); // Assuming this separator is between grid and articles

            if (!writingsGridContainer || !fullArticlesContainer || !separator) {
                 console.error("Writings section UI elements not found.");
                 return; // Abort if elements are missing
            }

            const defaultWritingsTitle = APP_CONFIG.DEFAULT_TITLES.writings;

            if (articleHash && articleHash.startsWith('#post-')) {
                const targetId = articleHash.substring(1); // Get the article ID
                const targetArticle = $(`#${targetId}`); // Find the article element

                // Hide the grid and separator
                writingsGridContainer.style.display = 'none';
                separator.style.display = 'none';

                // Ensure all articles are initially hidden (CSS :target handles showing the specific one)
                 $$('#full-articles-container article').forEach(article => {
                     // Note: CSS :target rule primarily controls display, but this ensures JS state consistency
                    article.style.display = 'none';
                 });


                if (targetArticle) {
                    // Show the target article (CSS :target might already do this, but this is belt-and-suspenders)
                    targetArticle.style.display = 'block';

                    // Update document title to the article title
                    const titleElement = targetArticle.querySelector('h2');
                    const articleTitle = titleElement ? titleElement.textContent.trim() : "Article";
                    document.title = `${articleTitle} - Writings - Agraj Dubey`;

                    // Scroll to the article and set focus for accessibility
                    setTimeout(() => { // Use a timeout to allow CSS display changes to apply
                        if (!isElementInViewport(targetArticle)) {
                             targetArticle.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }
                         // Set focusable attribute and focus the main heading
                        const heading = targetArticle.querySelector('h2');
                        if (heading) {
                            heading.setAttribute('tabindex', '-1'); // Make it focusable
                            heading.focus({ preventScroll: true }); // Focus without scrolling again
                        }
                    }, 100); // Small delay
                } else {
                    // If the specific article is not found, fall back to showing the grid
                     console.warn(`Article with ID ${targetId} not found. Showing writings grid.`);
                     window.location.hash = 'writings'; // Redirect back to main writings hash
                }

            } else {
                // If no specific article hash, show the grid and separator
                writingsGridContainer.style.display = 'grid'; // Or flex, based on your CSS grid setup
                separator.style.display = 'block'; // Or flex/grid etc.

                // Hide all individual articles
                 $$('#full-articles-container article').forEach(article => {
                     article.style.display = 'none';
                 });

                document.title = defaultWritingsTitle;

                // Set focus back to the grid or the last clicked link for accessibility
                setTimeout(() => {
                    if (typeof lastClickedReadMoreLink !== 'undefined' && lastClickedReadMoreLink && document.body.contains(lastClickedReadMoreLink)) {
                        // If the last action was clicking a 'Read More' link, try to focus it
                        lastClickedReadMoreLink.focus({preventScroll: true});
                        if (!isElementInViewport(lastClickedReadMoreLink)) {
                             lastClickedReadMoreLink.scrollIntoView({ behavior: 'smooth', block: 'center' });
                         }
                    } else {
                        // Otherwise, focus the main grid container
                        writingsGridContainer.setAttribute('tabindex', '-1'); // Make grid focusable
                        writingsGridContainer.focus({preventScroll: true});
                         if (!isElementInViewport(writingsGridContainer)) {
                             writingsGridContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
                         }
                    }
                    lastClickedReadMoreLink = null; // Clear the stored link
                }, 50); // Small delay

            }
        }


        // --- Home Section Animations ---
        /** Sets up hover effects for cards on the home page. */
        function setupHomeCardHoverEffects() {
             $$('#home-content .card').forEach(card => {
                 card.addEventListener('mousemove', (e) => {
                    const rect = card.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const centerX = rect.width / 2;
                    const centerY = rect.height / 2;
                    const rotateX = (y - centerY) / 20; // Adjust sensitivity
                    const rotateY = (centerX - x) / 20; // Adjust sensitivity
                    card.style.transform = `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) translateZ(20px)`; // Add translateZ for pop effect
                 });
                 card.addEventListener('mouseleave', () => {
                    card.style.transform = card.dataset.initialTransform || 'perspective(1000px) rotateX(0deg) rotateY(0deg) translateZ(0px)'; // Revert to initial state
                 });
                 // Prevent click on card from triggering when clicking the link inside
                 card.querySelectorAll('a').forEach(link => {
                     link.addEventListener('click', (e) => e.stopPropagation());
                 });
             });
        }

        /** Sets up scroll-triggered animations for elements on the home page. */
        function setupHomeScrollAnimations() {
             // Use a single observer with rootMargin to trigger slightly before element is fully visible
             const observerOptions = { threshold: 0.1, rootMargin: '0px 0px -30px 0px' };
             const observer = new IntersectionObserver((entries, obs) => {
                 entries.forEach(entry => {
                    // Check if the entry target is one of the rotating text elements
                     const isRotatingText = Object.keys(APP_CONFIG.ROTATING_TEXT_HOME).includes(entry.target.id);

                     if (entry.isIntersecting) {
                         // If it's intersecting and NOT a rotating text element, animate it
                         if (!isRotatingText) {
                            entry.target.style.opacity = '1';
                            // Restore the transform from the dataset (where we stored the target state)
                            entry.target.style.transform = entry.target.dataset.initialTransform || 'translateY(0)';
                            // Stop observing once animated
                            obs.unobserve(entry.target);
                         } else {
                            // If it's a rotating text element, the typewriter setup will handle its visibility/animation
                             // Ensure the observer for typewriter correctly sets isVisible = true
                         }
                     }
                 });
             }, observerOptions);

             // Define initial hidden states and target states for animation
             const heroSection = $('#heroSection');
             if (heroSection) {
                heroSection.style.opacity = '0';
                heroSection.style.transform = 'translateY(20px)';
                heroSection.dataset.initialTransform = 'translateY(0)'; // Store the target state
                heroSection.style.transition = 'opacity 0.8s ease-out, transform 0.8s ease-out'; // Apply transition
                observer.observe(heroSection); // Start observing
             }

             const writingsSectionHome = $('#writingsSectionHome');
             if (writingsSectionHome) {
                 writingsSectionHome.style.opacity = '0';
                 writingsSectionHome.style.transform = 'translateY(20px)';
                 writingsSectionHome.dataset.initialTransform = 'translateY(0)'; // Store the target state
                 writingsSectionHome.style.transition = 'opacity 0.8s ease-out, transform 0.8s ease-out'; // Apply transition
                 observer.observe(writingsSectionHome); // Start observing
             }

             // Observe the card elements with stagger delay
             $$('#home-content .card').forEach(card => {
                 const delay = parseInt(card.getAttribute('data-delay')) || 0; // Get delay from data attribute
                 card.style.opacity = '0';
                 // Initial transform before animation (can be different from final hover state)
                 card.style.transform = 'perspective(1000px) rotateX(10deg) rotateY(10deg) translateZ(-20px)';
                 card.dataset.initialTransform = 'perspective(1000px) rotateX(0deg) rotateY(0deg) translateZ(0px)'; // Store the target state
                 // Apply transition with delay
                 card.style.transition = `opacity 0.8s ease-out ${delay}ms, transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275) ${delay}ms`;
                 observer.observe(card); // Start observing
             });
        }

        /** Animates the circular profile image on the home page. */
        function animateCircularProfileImage() {
             const heroImage = $('#hero-circular-profile-image');
             if (heroImage) {
                 // Trigger the CSS transition by changing the style
                 heroImage.style.opacity = '1';
                 heroImage.style.transform = 'scale(1) translateY(0px)';
             }
        }


        // --- Typewriter Effects ---
        /** Sets up and manages a rotating typewriter effect for an element. */
        function setupRotatingText(elementId, config) {
            // Prevent setting up multiple times for the same element
            if (rotatingTextInstances[elementId]) {
                 // If already set up, just ensure the observer is active if the section is visible
                 if ($(`#${elementId}`) && $(`#${elementId}`).closest('.active-section')) {
                     rotatingTextInstances[elementId].observer.observe(rotatingTextInstances[elementId].element);
                 }
                return;
            }

            const element = document.getElementById(elementId);
            if (!element) {
                console.warn(`Element with ID "${elementId}" not found for rotating text.`);
                return; // Element not found
            }

            let currentIndex = -1; // Index of the currently displayed text
            let isBusy = false; // Flag to prevent overlapping animations
            let cycleTimeout = null; // Timer for the next cycle
            let isVisible = false; // Track if the element is currently in viewport

            // Determine if this element runs once or cycles
            const runOnce = (elementId === 'typewriter');

            // Clear initial content
            element.textContent = '';

            /** Types out a given text character by character. */
            function typeWriterInternal(text, callback) {
                let i = 0;
                isBusy = true;
                function type() {
                    // Stop if element is no longer visible or animation is cancelled
                    if (!isVisible || !isBusy) {
                        isBusy = false;
                        // Optionally clear text if hidden mid-animation, but keeping it might be smoother
                        // if (!isVisible) element.textContent = '';
                        return;
                    }
                    if (i < text.length) {
                        element.textContent += text.charAt(i);
                        i++;
                        setTimeout(type, config.typeSpeed);
                    } else {
                        // Add cursor at the end
                        if (element.querySelector('.typed-cursor')) element.removeChild(element.querySelector('.typed-cursor'));
                        const cursor = document.createElement('span');
                        cursor.className = 'typed-cursor';
                        element.appendChild(cursor);

                        isBusy = false;
                        if (callback) callback(); // Call the callback function
                    }
                }
                type(); // Start typing
            }

            /** Deletes text character by character. */
            function deleteWriterInternal(callback) {
                 // For elements that run only once, don't delete after typing
                if (runOnce && element.textContent.length > 0) {
                    if (callback) callback();
                    return;
                }

                let text = element.textContent;
                 // Remove existing cursor before deleting
                 const existingCursor = element.querySelector('.typed-cursor');
                 if (existingCursor) element.removeChild(existingCursor);

                // Re-get text after removing cursor
                 text = element.textContent;

                let i = text.length;
                isBusy = true;
                function del() {
                    // Stop if element is no longer visible or animation is cancelled
                     if (!isVisible || !isBusy) {
                         isBusy = false;
                         // if (!isVisible) element.textContent = '';
                         return;
                     }
                    if (i > 0) {
                        element.textContent = text.substring(0, i - 1);
                        i--;
                         // Re-add cursor after each character deletion if there's still text left
                         if (!element.querySelector('.typed-cursor') && element.textContent.length > 0) {
                            const cursor = document.createElement('span');
                            cursor.className = 'typed-cursor';
                            element.appendChild(cursor);
                         }
                        setTimeout(del, config.deleteSpeed);
                    } else {
                        // Remove cursor completely at the end
                        const finalCursor = element.querySelector('.typed-cursor');
                        if (finalCursor) element.removeChild(finalCursor);
                        element.textContent = ''; // Ensure element is empty
                        isBusy = false;
                        if (callback) callback(); // Call the callback
                    }
                }
                del(); // Start deleting
            }

            /** Schedules the next typing/deleting cycle. */
            function scheduleCycle(delay) {
                if (runOnce) return; // No cycling for run-once elements
                clearTimeout(cycleTimeout); // Clear any previous timer
                cycleTimeout = setTimeout(() => {
                    if(isVisible) { // Only start the cycle if element is visible
                        startCycle();
                    }
                }, delay);
            }

            /** Starts a full typing/deleting cycle. */
            function startCycle() {
                 // Prevent starting if already busy, not visible, or run-once
                if (runOnce || isBusy || !isVisible) return;

                // First, delete the current text
                deleteWriterInternal(() => {
                    // After deleting, if still visible, select the next text and type it
                    if (!isVisible) return; // Exit if visibility changed during deletion

                    let nextIndex;
                    // Select a random next text, avoiding the current one if more than one option exists
                    do {
                        nextIndex = Math.floor(Math.random() * config.texts.length);
                    } while (nextIndex === currentIndex && config.texts.length > 1);
                    currentIndex = nextIndex;
                    const nextText = config.texts[currentIndex];

                    element.textContent = ''; // Ensure element is empty before typing
                    typeWriterInternal(nextText, () => {
                        // After typing, schedule the next cycle
                        if (!runOnce) {
                            scheduleCycle(config.pauseDuration);
                        }
                    });
                });
            }

            // Use Intersection Observer to track visibility
            let initialized = false; // Flag to run initial typing only once
            const intersectionObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    const wasVisible = isVisible;
                    isVisible = entry.isIntersecting;

                    if (isVisible && !wasVisible) {
                        // Element became visible
                        if (!initialized) {
                            // First time visible, start the initial typing
                            initialized = true;
                            // Start with the first text or a random one for cycling elements
                            currentIndex = runOnce ? 0 : (elementId === 'main-heading-text' ? 0 : Math.floor(Math.random() * config.texts.length));
                            const firstText = config.texts[currentIndex];
                            element.textContent = ''; // Clear before typing
                            typeWriterInternal(firstText, () => {
                                // After typing, if it cycles, schedule the first pause/delete
                                if (!runOnce) {
                                    scheduleCycle(config.pauseDuration);
                                }
                            });
                        } else {
                            // Element became visible again after being hidden
                            if (!isBusy) { // Only resume/restart if not currently animating
                                if (runOnce) {
                                    // If run-once and empty, type again. If not empty, leave it.
                                    if(element.textContent === '') {
                                         element.textContent = ''; // Ensure empty
                                         typeWriterInternal(config.texts[0], () => {});
                                    } else {
                                         // Just add the cursor if needed
                                         if (!element.querySelector('.typed-cursor')) {
                                            const cursor = document.createElement('span'); cursor.className = 'typed-cursor'; element.appendChild(cursor);
                                         }
                                    }
                                } else {
                                     // For cycling elements, start the cycle (will delete current text if any)
                                    element.textContent = ''; // Clear any partial text
                                    scheduleCycle(100); // Short delay before starting the cycle
                                }
                            } else {
                                // If busy (mid-typing/deleting) when becoming visible, let the current animation finish
                                // The animation functions check `isVisible` and will continue if it's true
                            }
                        }
                    } else if (!isVisible && wasVisible) {
                        // Element became hidden
                        clearTimeout(cycleTimeout); // Stop any pending scheduled cycle
                        isBusy = false; // Mark as not busy (stops current animation loop iterations)
                        // Optionally clear element text immediately when hidden for cleaner state
                        // element.textContent = ''; // Uncomment this if you want text to disappear instantly on scroll out
                    }
                });
            }, { threshold: 0.1 }); // Trigger when 10% of the element is visible

            // Start observing the element
            intersectionObserver.observe(element);

            // Store the instance/observer for later management (e.g., pausing/resuming)
            rotatingTextInstances[elementId] = { observer: intersectionObserver, element: element };
        }


        // --- General UI Setup ---
        /** Sets up the mobile menu toggle functionality. */
        function setupMobileMenu() {
            const navToggle = $('#nav-toggle');
            const mobileMenu = $('#mobile-menu');
            if (navToggle && mobileMenu) {
                navToggle.addEventListener('click', () => {
                    const isOpen = mobileMenu.classList.toggle('is-open');
                    navToggle.setAttribute('aria-expanded', String(isOpen));
                });
                // Close mobile menu when a link is clicked
                $$('#mobile-menu a').forEach(link => {
                    link.addEventListener('click', () => {
                        mobileMenu.classList.remove('is-open');
                        navToggle.setAttribute('aria-expanded', 'false');
                    });
                });
            }
        }

        /** Sets up the scroll progress bar functionality. */
        function setupScrollProgressBar() {
            const progressBar = $("#progressBar");
            if (!progressBar) return;

            // Passive event listener for performance
            window.addEventListener('scroll', () => {
                const winScroll = document.body.scrollTop || document.documentElement.scrollTop;
                const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
                 // Prevent division by zero if the page is not scrollable
                const scrolled = height > 0 ? (winScroll / height) * 100 : 0;
                progressBar.style.width = scrolled + "%";
            }, { passive: true });
        }

        /** Sets up the click listener for the static image (easter egg). */
        function setupStaticImageClick() {
            const imageElement = $('#staticImageHome');
            if (!imageElement) return;

            // List of random YouTube links
            const videoUrls = [
                'https://www.youtube.com/watch?v=dQw4w9WgXcQ', // Rick Roll
                'https://www.youtube.com/watch?v=-jGBp5HBLFs',
                'https://www.youtube.com/shorts/2Dv2hO3rYVg',
                'https://www.youtube.com/watch?v=x6YcdgB9e48',
                'https://www.youtube.com/shorts/D-kkjR0NyGg',
                'https://www.youtube.com/shorts/LFsS-9lT0Rk',
                'https://www.youtube.com/shorts/TTU1g8IU22I'
            ];

            imageElement.addEventListener('click', () => {
                const randomIndex = Math.floor(Math.random() * videoUrls.length);
                window.open(videoUrls[randomIndex], '_blank'); // Open in a new tab
            });
        }


        // --- Initial Setup and Event Listeners ---
        /** Initializes the application when the DOM is ready. */
        document.addEventListener('DOMContentLoaded', async () => {
            // Initialize audio elements once the DOM is ready
            revealSoundEl = $('#revealSound');
            gameSpawnSoundEl = $('#gameSpawnSound');
            gameWinSoundEl = $('#gameWinSound');

            // Setup Hyperspeed background
            resizeHyperspeedCanvas();
            initStars();
            animateHyperspeed(); // Start animation loop
            window.addEventListener('resize', resizeHyperspeedCanvas);

            // Setup UI components
            setupMobileMenu();
            setupScrollProgressBar();
            setupStaticImageClick(); // Setup click listener for the Frieren ring

            // Load external data first
            await loadAndRenderPosts(); // Wait for posts to load before handling routing

            // Event delegation for "Read More" links in Writings previews
            // Use a single listener on a parent element to handle clicks on dynamically added cards
             document.body.addEventListener('click', function(event) {
                 // Check if the clicked element or its parent is a 'Read More' link
                 const readMoreLink = event.target.closest('#writings-grid-container a.read-more-link, #home-recent-writings-grid a[href^="#post-"]');
                 if (readMoreLink) {
                     // Store the reference to the clicked link *before* the hash change updates the UI
                     lastClickedReadMoreLink = readMoreLink;
                     // Let the default link behavior (changing the hash) trigger handleMainRouteChange
                 }
             });

            // Handle the initial route/hash on page load
            handleMainRouteChange();

            // Listen for hash changes to navigate between sections
            window.addEventListener('hashchange', handleMainRouteChange);

            // Set current year in footer
            const currentYearEl = $('#currentYear');
            if(currentYearEl) currentYearEl.textContent = new Date().getFullYear();

            // Setup the secret game
            setupSecretGame();
        });

    </script>
</body>
</html>
